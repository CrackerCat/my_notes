所有程序都必须管理其运行时使用计算机内存的方式。一些语言中具有垃圾回收机制，在程序运行时有规律地寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust 则选择了第三种方式：通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。如果违反了任何这些规则，程序都不能编译。在运行时，所有权系统的任何功能都不会减慢程序。

### 栈（Stack）与堆（Heap）

栈：进栈、出栈。
堆：分配、释放。

入栈比在堆上分配内存要快。
访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。

### 所有权规则

1. 每一个值都有一个**所有者**
2. 值在任一时刻有且只有一个所有者
3. 当所有者（变量）离开作用域，这个值将被丢弃

### 作用域

变量从声明的点开始直到当前 **作用域** 结束时都是有效的。

### String 类型

我们已经见过字符串字面值，即被硬编码进程序里的字符串值。字符串字面值是很方便的，不过它们并不适合使用文本的每一种场景。原因之一就是它们是不可变的。另一个原因是并非所有字符串的值都能在编写代码时就知道。

可以使用 `from` 函数基于字符串字面值来创建 `String`，如下：

```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() 在字符串后追加字面值
println!("{}", s); // 将打印 `hello, world!`
```

两个冒号 :: 是运算符，允许将特定的 from 函数置于 String 类型的命名空间（namespace）下，而不需要使用类似 string_from 这样的名字。可以修改此类字符串。

### 内存与分配

对于 `String` 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容。
当调用 `String::from` 时，它的实现请求其所需的内存。这在编程语言中是非常通用的。
然而，第二部分实现起来就各有区别了。在有**垃圾回收**的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它。在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。如果忘记回收了会浪费内存。如果过早回收了，将会出现无效变量。如果重复回收，这也是个 bug。我们需要精确的为一个 `allocate` 配对一个 `free`。
当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 `drop`。

变量与数据的交互方式（一）：移动

**移动后原变量不再有效**
`String` 由三部分组成，一个指向存放字符串内容内存的指针，一个长度，和一个容量。这一组数据存储在栈上。实际内容部分在堆上存放。
发生移动时，栈上数据复制，堆上数据不变。这样会有一个问题，离开作用域时，会尝试释放相同的内存，引发**二次释放**的错误，也是内存安全性bug之一，会导致内存污染。为了确保内存安全，在 `let s2 = s1;` 之后，Rust 认为 `s1` 不再有效，因此 Rust 不需要在 `s1` 离开作用域后清理任何东西。

```rust
let s1 = String::from("hello");
let s2 = s1;
println!("{}, world!", s1);
```

这段代码会得到类似禁止你使用无效的引用的错误。

如果你在其他语言中听说过术语 **浅拷贝**（_shallow copy_）和 **深拷贝**（_deep copy_），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。不过因为 Rust 同时使第一个变量无效了，这个操作被称为 **移动**（_move_），而不是叫做浅拷贝。
另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。因此，任何 **自动** 的复制可以被认为对运行时性能影响较小。

变量与数据交互的方式（二）：克隆

**可以通过克隆使原变量仍然有效**
如果我们 **确实** 需要深度复制 `String` 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 `clone` 的通用函数。

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
println!("s1 = {}, s2 = {}", s1, s2);
```

这与只在栈上的数据：拷贝，有所不同
**拷贝只针对于简单数据类型，及其元组，拷贝后变量仍然有效**

```rust
let x = 5;
let y = x;
println!("x = {}, y = {}", x, y);
```

Rust 有一个叫做 `Copy` trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。如果一个类型实现了 `Copy` trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。

### 所有权与函数

**将值传递给函数与给变量赋值的原理相似**。向函数传递值可能会移动或者复制，就像赋值语句一样。除可拷贝的几种数据类型外，**传递后不再有效**。
变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。当持有堆中数据值的变量离开作用域时，其值将通过 `drop` 被清理掉，除非数据被移动为另一个变量所有。

```rust
fn main() {
    let x = 5;
    let y = x;
    println!("x = {}, y = {}", x, y);
    println!("x = {}, y = {}", x, y); // 没问题
    
    let s1 = String::from("hello");
    let s2 = s1;
    // println!("s1 = {}, s2 = {}", s1, s2) // 错误，s1已经被移动到s2
    println!("s2 = {}", s2);
    println!("s2 = {}", s2); // 没问题 println!宏实现了Copy trait

    my_print(s2);
    // my_print(s2); // 错误，s2已经被移动到my_print函数中
}

fn my_print(s: String) {
    println!("{}", s);
}
```

虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦（比如使用我们可以使用元组来返回多个值）。如果我们想要函数使用一个值但不获取所有权该怎么办呢？这种场景应该很常见Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 **引用**（_references_）。

### 引用与借用

**引用**（_reference_）像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据。 与指针不同，引用确保指向某个特定类型的有效值。引用离开作用域时，什么都不会发生。我们将创建一个引用的行为称为 **借用**（_borrowing_）。

```rust
fn main() {
    let s = String::from("hello");

    change(&s);
}

fn change(some_string: &String) {
    some_string.push_str(", world");
}
```

如果我们尝试修改借用的变量呢？这行不通！（默认）不允许修改引用的值。

### 可变引用

```rust
fn main() {
    let mut s = String::from("hello"); // 注意这里必须是可变变量mut

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。这些尝试创建两个 `s` 的可变引用的代码会失败

```rust
let mut s = String::from("hello");

let r1 = &mut s;
let r2 = &mut s;

println!("{}, {}", r1, r2);
```

这个限制的好处是 Rust 可以在编译时就避免数据竞争。**数据竞争**（_data race_）类似于竞态条件，它可由这三个行为造成：

-   两个或更多指针同时访问同一数据。
-   至少有一个指针被用来写入数据。
-   没有同步数据访问的机制。

这样可以：

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 在这里离开了作用域，所以我们完全可以创建一个新的引用

let r2 = &mut s;
```

同时使用可变与不可变引用时也采用的类似的规则

```rust
let mut s = String::from("hello");

let r1 = &s; // 没问题
let r2 = &s; // 没问题
let r3 = &mut s; // 大问题

println!("{}, {}, and {}", r1, r2, r3);
```

即我们也不能在拥有不可变引用的同时拥有可变引用

```rust
let mut s = String::from("hello");

let r1 = &s; // 没问题
let r2 = &s; // 没问题
println!("{} and {}", r1, r2);
// 此位置之后 r1 和 r2 不再使用

let r3 = &mut s; // 没问题
println!("{}", r3);
```

不可变引用的用户可不希望在他们的眼皮底下值就被意外的改变了！然而，**多个不可变引用是可以的**，因为没有哪个只能读取数据的人有能力影响其他人读取到的数据。
**可变引用后不能再使用其它引用**

### 悬垂引用

在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 **悬垂指针**（_dangling pointer_），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。

```rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。
```

解决方法是直接返回 `String`

```rust
fn no_dangle() -> String {
    let s = String::from("hello");

    s
} // 所有权被移动出去，所以没有值被释放
```

让我们概括一下对引用的讨论：

-   在任意给定时间，**要么** 只能有一个可变引用，**要么** 只能有多个不可变引用。
-   引用必须总是有效的。

### Slice 类型

尝试以下案例：返回字符串的第一个单词长度

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes(); // 转化为字节数组
	// 迭代器 `iter`返回每一个元素 `enumerate` 包装结果 将元素作为元组的一部分返回
    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
```

字符串 slice 示例

```rust
let s = String::from("hello world");

let hello = &s[0..5];
// 等价于
let hello0 = &s[..5];

let world = &s[6..11];
// 等价于
let world = &s[6..];

let all = &s[..];
```

重写

```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

fn main() {
    let mut s = String::from("hello world");

    let word = first_word(&s);

    s.clear(); // 错误！

    println!("the first word is: {}", word);
}
```

编译器会报错！当拥有某值的不可变引用时，就不能再获取一个可变引用。因为 `clear` 需要清空 `String`，它尝试获取一个可变引用。

**字符串字面值就是 `slice`**，它的类型是 `&str`

其它类型的 `slice`：如数组 `slice`